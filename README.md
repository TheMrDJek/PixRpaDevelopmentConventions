# PIX RPA Development Conventions & Best Practices

Стандартизированные соглашения и рекомендации для разработки роботов на платформе PIX RPA.  
Цель репозитория — обеспечить единый подход к проектированию, документированию и поддержке автоматизированных процессов.

## Зачем нужны соглашения и лучшие практики для PIX RPA?

Следование согласованным принципам и рекомендациям при разработке RPA-решений на платформе PIX обеспечивает ряд существенных преимуществ как для отдельных разработчиков, так и для команд. Применение описанных в данном документе подходов позволяет достичь следующих результатов:

**Улучшенная поддерживаемость:** `Четкая организация кода`,`Упрощение навигации по проекту`,`Быстрое понимание структуры новыми разработчиками`,`Упрощение рефакторинга`

**Повышенная надежность:** `Изолированные компоненты`,`Улучшенная обработка ошибок`,`Упрощение отладки`,`Снижение рисков при изменениях`

**Масштабируемость:** `Легкость добавления новых функций/скриптов`,`Упрощение интеграции с другими системами`,`Возможность параллельной разработки`

**Безопасность:** `Централизованное управление конфигурацией`,`Защита конфиденциальных данных`, `Контроль доступа к ресурсам`, `Улучшенное логирование`

**Эффективность разработки:** `Ускорение разработки новых роботов`,`Уменьшение дублирования кода`,`Упрощение тестирования`,`Снижение затрат на поддержку`

**Улучшенное качество:** `Стандартизированный подход`,`Улучшенная читаемость кода`,`Упрощение код-ревью`,`Снижение количества ошибок`

**Что включено в этот документ:**
- Соглашения по именованию (переменных, функций, проектов) для повышения читаемости кода
- Структура проекта: организация файлов и каталогов для удобства масштабирования
- Паттерны разработки и лучшие практики

**Практическая польза:**
- Упрощение onboarding новых разработчиков
- Снижение числа ошибок за счет унификации процессов
- Упрощение интеграции с метаданными и внешними системами
- Повышение эффективности командной работы

**Участвуйте в развитии!**  
Репозиторий открыт для предложений и доработок — создавайте Issues или Pull Requests, чтобы улучшить стандарты сообщества.

## В этой статье

- (NEW) [Соглашение об администрировании мастера] // В работе 
- [Соглашение о структуре проекта](#соглашение-о-структуре-проекта) //В работе, будет доп по другим шаблонам
- [Соглашение о Git](#соглашения-о-git)
- [Соглашение об именовании](#соглашение-об-именовании)
- [Соглашение о БД](#соглашение-о-бд)
- [Соглашение об очередях](#соглашение-об-очередях)
- [Соглашение о логировании](#соглашение-о-логировании)
- [Соглашение об исключениях](#соглашения-об-исключениях) //В работе
- [Рекомендации по написанию скриптов](#рекомендации-по-написанию-скриптов)
- (NEW) [Рекомендации о тестировании] //В работе

Стандарт скрипта необходим для поддержания удобочитаемости скрипта, согласованности и совместной работы в команде разработчиков. Скрипт, который соответствует отраслевым методикам и установленным рекомендациям, проще понимать, поддерживать и расширять. Большинство проектов применяют согласованный стиль с помощью соглашений о скрипте.

## Соглашение о структуре проекта

**Примечание:** В этом разделе речь идет в основном только о Unattended Robots и бизнес-процессах, подходящих под шаблон State Machine на транзакциях. Информация по другим шаблонам и Attended Robots будет добавлена позже. Все роботы работают в связке с PIX Master (Оркестратор).

<details>
    <summary><b>Разделение проекта на слои</b></summary>

Разделение проекта на слои - это архитектурный подход, при котором код организуется в логические группы (слои) в соответствии с их ответственностью. Это позволяет:
- Улучшить организацию кода
- Упростить поддержку и масштабирование
- Обеспечить четкое разделение ответственности
- Облегчить тестирование
- Повысить переиспользование кода

**Структура проекта:**
```console
├───Common (слой шаблонов и прочих файлов)
├───Helpers (слой независимых функций)
├───Infrastructure (слой работы с сервисами/интеграциями - может использоваться в разных State)
│   ├───DataBase (работа с бд)
│   ├───Mail (работа с почтой)
│   └───Http Client (работа с API сервиса)
├───States (слой состояний)
│   ├───Init
│   │   └───Transactions
│   ├───GetSetTransaction
│   │   └───Transactions
│   ├───Process
│   │   └───Transactions
│   └───EndProcess
└───Tests (слой тестов)
    ├───IntegrationTests
    └───UnitTests
```

**Описание слоев:**

1. **Common** - содержит общие компоненты проекта:
- Шаблоны документов
- Общие ресурсы

2. **Helpers** - включает вспомогательные функции:
- Утилиты для работы с данными
- Вспомогательные методы
- Общие алгоритмы

3. **Infrastructure** - слой для работы с внешними системами:
- Подключение к базам данных
- Работа с почтой
- Интеграции Http,SOAP Client

4. **States** - основной слой бизнес-логики:
- INIT - инициализация и подготовка
- GET/SET TRANSACTION - работа с транзакциями
- PROCESS - обработка данных
- END PROCESS - завершение работы

5. **Tests** - слой для тестирования:
- e2e тесты
- Интеграционные тесты
- Модульные тесты

**Преимущества разделения на слои:**
- Улучшенная организация кода и его навигация
- Упрощение поддержки и масштабирования
- Четкое разделение ответственности
- Упрощение тестирования
- Улучшение переиспользования кода

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте шаблон на основе State Machine</b></summary>

[Список шаблонов](https://github.com/TheMrDJek/pix-templates)

**Преимущества использования State Machine:**
- Четкое разделение логики на состояния
- Упрощение отладки и мониторинга
- Возможность остановки и возобновления процесса
- Улучшенная обработка ошибок
- Масштабируемость решения

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте слои по назначению</b></summary>

Робот должен состоять минимум из 3 основных состояний:

**Базовая структура (3 состояния):**
1. Init
2. ProcessTransaction
3. End Process

**Расширенная структура (4 состояния) для бизнес-процессов с транзакциями/циклами/коллекциями:**
1. Init
2. Get/Set Transaction
3. ProcessTransaction
4. End Process

**INIT**
---
Состояние INIT используется для инициализации робота, в этом блоке мы реализуем:
- Сброс ошибок
- Инициализация конфига
- Проверка доступов (доступ к бд, к папке, к api и так далее)
- Запуск и авторизация в приложение если мы работаем с UI
- Парсинг данных, если мы работаем не с очередями

**GET/SET TRANSACTION**
---
Состояние GET/SET TRANSACTION используется для получения транзакции* роботом, в этом
<br> блоке мы реализуем:</br>
- Получение транзакции
- Обработка сигнала стоп из мастера

транзакция в роботе* - минимальный набор данных для обработки сущностей/домена.

Например:
- Если робот обрабатывает очередь, то транзакцией будет - элемент очереди
- Если робот обрабатывает письма, то транзакцией будет - письмо
- Если робот обрабатывает папку с файлами, то транзакцией будет - файл

**PROCESSING TRANSACTION**
---
Состояние PROCESSING TRANSACTION используется для обработки транзакции роботом, в этом блоке мы реализуем:
- Обработка транзакции

**ВАЖНО:**
Не размазывайте бизнес логику связанную с транзакцией на другие состояние, 
если нужно отправить письмо, сохранить значения, отправить отчет по транзакции,
то все реализуем в этом состоянии и его ветках.

**END PROCESS**
---
Состояние END PROCESS используется для завершения робота, в этом блоке мы реализуем:
- Отключение соединений
- Закрытие приложений (если нужно, лучше оставлять по не закрытым что бы при <br>след запусках робота не тратить время на авторизацию и запуск самого приложения)
- Проверка ошибок
- Удаление временных папок

**ВАЖНО:**
Не игнорирейте ошибки, если у вас в каком то состоянии произошла системная ошибка робот должен завершиться с ошибкой

**Преимущества четкого разделения состояний:**
- Улучшенная читаемость кода
- Упрощение отладки
- Возможность повторного использования состояний
- Улучшенный контроль над процессом
- Упрощение тестирования

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте ассеты мастера для хранения конфигурации</b></summary>

Конфиг должен быть реализован с учетом использование ассетов только из мастера.<br>
Заполнение конфига из других место увеличивает кол-во зависимостей, плюс может приводить к ошибкам.

Например:
- excel файл не доступен
- потеря соединения с бд

**Преимущества использования ассетов мастера:**
- Централизованное управление конфигурацией
- Упрощение развертывания
- Возможность быстрого изменения настроек
- Улучшенная безопасность
- Упрощение поддержки

**Входные параметры робота:**
- Помимо ассетов можно использовать входные параметры робота
- Все входные параметры имеют тип string
- Подходят для передачи динамических значений при запуске робота
- Не рекомендуется использовать для хранения конфигурационных данных

**Работа с контурами (Dev/UAT/Prod):**
- Ассеты с одинаковыми именами могут существовать в разных контурах
- При переносе робота между контурами значения в ассетах автоматически берутся из соответствующего оркестратора
- Это позволяет иметь разные настройки для разных окружений без изменения кода робота
- Важно поддерживать одинаковую структуру ассетов во всех контурах
- В рамках одного контура можно переопределять значения ассетов для разных агентов (например, для test и prod агентов)
- Переопределение значений происходит в настройках ассетов, где можно привязать конкретные значения к определенным роботам

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте зашифрованные ассеты для хранения конфиденциальных данных</b></summary>

Конфиденциальные данные, такие как учетные записи, пароли, токены доступа и строки подключения должны храниться в специальных защищенных ассетах PIX Master.

**Типы ассетов для хранения конфиденциальных данных:**
- **Защищенные данные** - для хранения общей конфиденциальной информации
- **Учетные данные для авторизации** - специально для хранения логинов и паролей

**Преимущества использования защищенных ассетов:**
- Встроенное шифрование данных в хранилище
- Разграничение доступа на уровне мастера
- Снижение риска утечки конфиденциальной информации
- Централизованное управление учетными данными
- Возможность ротации учетных данных без изменения кода роботов
- Лог доступа к защищенным ассетам

**Примеры данных для хранения в защищенных ассетах:**
- Учетные данные для подключения к базам данных
- Пароли для доступа к внешним системам
- API-ключи и токены для внешних сервисов
- Сертификаты и ключи шифрования
- Данные для аутентификации в корпоративных системах
- Персональные данные сотрудников

**Последствия несоблюдения:**
- Хранение паролей в открытом виде в исходном коде или конфигурационных файлах
- Риск утечки конфиденциальной информации при доступе к репозиторию
- Сложности при необходимости регулярного обновления паролей
- Нарушение политик информационной безопасности
- Потенциальные проблемы при проверках и аудитах безопасности

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Храните шаблоны и прочие файлы в самом проекте робота</b></summary>

Не используйте сетевые, временные папки для хранения шаблонов. в PIX можно хранить подобные файлы в самом проекте робота

![alt text](/common/AddPatternFile.png)

**Преимущества хранения файлов в проекте:**
- Упрощение развертывания
- Улучшенная версионность
- Отсутствие внешних зависимостей
- Упрощение миграции
- Улучшенная изоляция проекта

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Управление временными файлами</b></summary>

При работе с файлами в процессе выполнения роботов важно соблюдать правила хранения временных файлов для обеспечения стабильности и безопасности системы.

**Используйте системную временную директорию:**
- Всегда используйте системную папку Temp для временных файлов вместо жестко заданных путей
- Получайте путь к системной временной директории с помощью класса [Path](https://learn.microsoft.com/ru-ru/dotnet/api/system.io.path)
- Никогда не храните временные файлы внутри проекта робота или в корневых директориях дисков

**Рекомендации по работе с временными файлами:**
- Создавайте уникальные имена для временных файлов (используйте Guid)
- Обязательно удаляйте временные файлы после использования, после исключения или очищайте временные папки перед использованием
- Логируйте операции создания и удаления временных файлов **для отладки**

**Запрещенные практики:**
- Хранение временных файлов в проекте робота: `@"C:\Projects\MyBot\temp\file.xlsx"`
- Хардкодинг путей: `@"C:\Temp\file.xlsx"` или `@"D:\WorkFiles\temp.csv"`
- Использование локальных папок без проверки доступности: `@".\temp\file.xlsx"`
- Создание временных файлов без механизма их гарантированного удаления

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте использования общих библиотек с другими роботами</b></summary>

Использование общих Utils(кастомных) библиотек или скриптов с другими роботами приводит к зависимости робот друг от друга или других конфликтах

За частую если требуется внести изменения в библиотеку, то приходится вностить изменения в несколько роботов сразу, что приводит к увеличению трудозатрат и нарушению DRY.

В качестве решения, можно держать набор общих библитек, но после использования в проекте развивать отдельно в рамках одного проекта.

**Преимущества отказа от общих библиотек:**
- Независимость проектов
- Упрощение поддержки
- Отсутствие побочных эффектов при изменениях
- Улучшенная изоляция

**[⬆ К началу статьи](#в-этой-статье)**

</details>

## Соглашения о Git

Git — это основной инструмент для контроля версий при разработке роботов на PIX RPA. Правильная организация работы с Git существенно повышает эффективность как индивидуальной, так и командной разработки.

<details>
    <summary><b>Используйте осмысленные названия коммитов</b></summary>

Правильное название коммита должно описывать, что именно было изменено, и по возможности — почему. Это облегчает понимание истории проекта и упрощает откат изменений в будущем.

**Рекомендуемый формат:**
```
<тип>: <краткое описание изменений>

<подробное описание, если необходимо>
```

Типы коммитов:
- `feat`: новая функциональность
- `fix`: исправление ошибки
- `docs`: изменения в документации
- `style`: форматирование, отступы (не влияют на логику)
- `refactor`: рефакторинг кода без изменения функциональности
- `test`: добавление или изменение тестов
- `chore`: обновление внешних зависимостей, настройка сборки
- `wip`: промежуточная работа (Work In Progress) — для коммитов с частичной реализацией функциональности

**Примеры хороших названий коммитов:**
- `feat: добавлен модуль распознавания счетов-фактур`
- `fix: исправлена логика обработки транзакций при потере соединения`
- `refactor: оптимизирована выборка данных из БД для уменьшения потребления памяти`
- `docs: обновлена документация по настройке подключения к API`
- `wip: начата реализация парсера документов`
- `wip: добавлена часть логики Init`
- `feat: реализована валидация входных параметров в Init`
- `feat: добавлен модуль работы с API в Processing`

**Сценарии использования коммитов типа `wip` и `feat`:**

1. **Промежуточная работа (wip):**
   - Когда нужно сохранить прогресс, но функциональность еще не завершена
   - При реализации части большого блока (например, часть состояния Init)
   - Для сохранения работы в конце рабочего дня
   - Коммиты можно делать в личную ветку разработки

 **Рекомендации по коммитам промежуточной работы:**
- Стремитесь делать частые маленькие коммиты вместо редких больших
- Явно помечайте незавершенную работу префиксом `wip:`
- При командной разработке работайте с промежуточными коммитами в личных ветках
- Используйте `git rebase -i` перед слиянием в основную ветку для объединения промежуточных коммитов

2. **Завершенная функциональность (feat):**
   - Когда реализована законченная функция, даже если это часть большего блока
   - Если изменение можно протестировать отдельно
   - Такие коммиты подходят для отправки на ревью

**Сценарии использования других типов коммитов:**

3. **Исправление ошибок (fix):**
   - Устранение багов в существующей функциональности
   - Исправление некорректной логики обработки данных
   - Решение проблем совместимости или производительности
   - Примеры: `fix: исправлено зависание при отсутствии ответа от API`, `fix: устранена утечка памяти при обработке больших файлов`

4. **Документация (docs):**
   - Обновление или создание документации к роботу
   - Добавление комментариев к сложным участкам кода
   - Создание или обновление README, руководств пользователей, технических спецификаций
   - Примеры: `docs: создано руководство по настройке робота`, `docs: обновлено описание параметров конфигурации`

5. **Стиль (style):**
   - Форматирование кода без изменения его функциональности
   - Переименование переменных для большей понятности
   - Изменение отступов, пробелов, переносов строк
   - Примеры: `style: переформатирован код по стандартам проекта`, `style: улучшена читаемость скрипта обработки транзакций`

6. **Рефакторинг (refactor):**
   - Изменение структуры кода без изменения его функциональности
   - Оптимизация производительности существующего кода
   - Перенос логики между компонентами для лучшей архитектуры
   - Примеры: `refactor: оптимизирована обработка транзакций для повышения производительности`, `refactor: перенесены общие функции в Helper-компонент`

7. **Тестирование (test):**
   - Добавление или изменение тестов для существующего кода
   - Создание тестовых данных или сценариев
   - Настройка автоматизированного тестирования
   - Примеры: `test: добавлены тесты для валидации входных данных`, `test: созданы тестовые сценарии для обработки ошибочных ситуаций`

8. **Обслуживание (chore):**
   - Обновление внешних зависимостей или версий библиотек
   - Изменения в системе сборки или настройках проекта
   - Административные задачи, не влияющие напрямую на код
   - Примеры: `chore: обновлены настройки проекта`, `chore: изменена структура папок проекта`

</details>

<details>
    <summary><b>Следуйте стратегии ветвления</b></summary>

Для разработки RPA-проектов на PIX RPA с использованием Git рекомендуется следующая стратегия. Она поможет организовать ветки, коммиты и процессы так, чтобы команда легко ориентировалась в изменениях, особенно при работе с несколькими роботами.

**1. Стратегия веток (Branching Strategy)**

Используйте адаптированный GitFlow или GitHub Flow с акцентом на разделение по роботам:

| Тип ветки | Назначение | Пример имени ветки |
|-----------|------------|---------------------|
| `main` | Стабильная версия всех роботов (только релизные версии) | `main` |
| `develop` | Интеграционная ветка для текущей разработки | `develop` |
| `feature/{robot}/{task}` | Разработка нового робота или функционала существующего | `feature/InvoiceProcessing/ocr-update` |
| `fix/{robot}/{issue}` | Исправление бага в конкретном роботе | `fix/InvoiceProcessing/duplicate-entry` |
| `release/{robot}/{version}` | Подготовка к релизу робота (тестирование, документация) | `release/InvoiceProcessing/v1.2.0` |
| `hotfix/{robot}/{issue}` | Срочные исправления в релизной версии робота | `hotfix/InvoiceProcessing/login-error` |

**Модели ветвления:**

<details>
  <summary><b>GitFlow — для комплексных проектов с плановыми релизами</b></summary>

  ![GitFlow Model](common/GitFlow.png)

  **GitFlow** подходит для RPA-проектов со строгим циклом релизов. Эта модель предоставляет четкую структуру для управления разработкой, тестированием и выпуском новых версий роботов:
  
  - **master/main**: содержит только стабильные релизы роботов
  - **develop**: основная ветка разработки
  - **feature branches**: для разработки новых роботов/функций
  - **release branches**: для подготовки к релизу
  - **hotfix branches**: для срочных исправлений в релизной версии
  
  **Когда использовать GitFlow:**
  - Сложные роботы с долгосрочной поддержкой
  - Командная разработка с четкими ролями
  - Необходимость поддержки нескольких версий роботов
</details>

<details>
  <summary><b>GitHub Flow — для быстрой итеративной разработки</b></summary>

  ![GitHub Flow Model](common/GithubFlow.png)

  **GitHub Flow** — более простая модель, ориентированная на непрерывную доставку и интеграцию. Этот подход хорошо подходит для RPA-проектов с частыми обновлениями:
  
  - **main**: всегда содержит рабочую версию, готовую к деплою
  - **change branches**: создаются для любых изменений (новые функции, исправления и т.д.)
  - После тестирования изменения сливаются напрямую в main
  
  **Когда использовать GitHub Flow:**
  - Небольшие роботы или быстрые изменения
  - Непрерывная доставка и деплой
  - Небольшие команды или индивидуальная разработка
</details>

**2. Именование веток**

Четко указывайте робота и задачу:
- Для разработки: `feature/InvoiceProcessing/add-email-trigger`
- Для исправлений: `fix/DataExtraction/column-missing`
- Для хотфиксов: `hotfix/ReportGenerator/date-format`

Избегайте общих названий вроде `fix-bug` или `update` — всегда уточняйте контекст.

**Привязка к задачам в Jira:**

Для улучшения отслеживания задач рекомендуется включать идентификатор задачи Jira в название ветки:

- `feature/InvoiceProcessing/RPA-56-api-integration`
- `fix/PayrollBot/RPA-128-incorrect-calculation`
- `hotfix/CustomerOnboarding/RPA-237-auth-error`
- `feature/common/RPA-84-excel-library`

При такой структуре:
- `RPA-56` - идентификатор задачи в Jira
- `InvoiceProcessing` - название робота
- `api-integration` - краткое описание задачи

Этот подход позволяет автоматически связывать коммиты с задачами в Jira и упрощает отслеживание прогресса.

**3. Процесс разработки**

**Для индивидуальной разработки (один разработчик):**
- Создайте ветку `feature/{robot}/{task}` из `develop`
- Разрабатывайте функционал с регулярными коммитами
- Создайте Pull Request в `develop` для самопроверки
- После завершения работы и тестирования, выполните слияние через Pull Request

**Для командной разработки:**
- Архитектор проекта создает ветку `develop` с базовой структурой роботов
- Разработчики создают ветки `feature/{robot}/{task}` для конкретных задач
- Слияние в `develop` выполняется через Pull Request после код-ревью
- Подготовка релиза осуществляется в ветке `release/{robot}/{version}`
- После тестирования релиз сливается в `main` и `develop`

**4. Управление релизами**

- Создавайте теги для релизов в формате `{robot}-v{MAJOR}.{MINOR}.{PATCH}`
- Документируйте изменения в CHANGELOG.md для каждого робота
- Для срочных исправлений создавайте ветки `hotfix/{robot}/{issue}` от `main`
- После исправления сливайте хотфикс в обе ветки: `main` и `develop`

**5. Особенности работы с несколькими роботами**

- Используйте префикс с именем робота во всех ветках (кроме `main` и `develop`)
- В сообщениях коммитов указывайте робота: `[InvoiceProcessing] feat: добавлен модуль OCR`
- Для общих компонентов используйте префикс `common`: `feature/common/api-client`
- Приоритизируйте изменения в общих компонентах, чтобы минимизировать конфликты

**Примеры workflow:**

1. **Разработка нового функционала:**
   ```
   develop → feature/InvoiceProcessing/add-validation → Pull Request → develop
   ```

2. **Релиз робота:**
   ```
   develop → release/InvoiceProcessing/v1.0.0 → тестирование → main (+ тег InvoiceProcessing-v1.0.0)
   ```

3. **Хотфикс производственной версии:**
   ```
   main → hotfix/InvoiceProcessing/fix-api-error → main и develop
   ```

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте Pull/Merge Request для изменений</b></summary>

Даже работая в одиночку, используйте механизм Pull Request для внесения изменений в основные ветки. Это обеспечивает дополнительный уровень проверки и документирует внесенные изменения.

**Для индивидуальной разработки:**
- Создавайте PR для слияния функциональных веток в основную
- Используйте PR как механизм самопроверки
- Документируйте ключевые решения в описании PR

**Для командной разработки:**
- Обязательно используйте PR для всех изменений в основных ветках
- Назначайте необходимых ревьюеров для каждого PR
- Приводите контекст задачи и список внесенных изменений

**Рекомендации для эффективных PR:**
**Описывайте контекст изменений**:
- Что было сделано и почему
- Как тестировалось
- Связанные задачи или проблемы

**Делайте небольшие PR**:
- Проще для проверки
- Снижение конфликтов слияния
- Быстрее получение обратной связи

**Используйте чек-листы** для отслеживания прогресса

**Рекомендации для ревью кода:**
- Сосредотачивайтесь на логике и архитектуре, а не на форматировании
- Используйте конструктивные комментарии
- Проверяйте обработку исключений и крайних случаев
- Обращайте внимание на производительность для операций с большими данными

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Настройте .gitignore для PIX-проектов</b></summary>

Правильная настройка .gitignore предотвращает попадание в репозиторий временных, автоматически генерируемых и конфиденциальных файлов.

**Типичные элементы .gitignore для PIX RPA проектов:**

```gitignore
# Папки для временных файлов
[Tt]emp/
[Ll]ogs/
[Tt]estResults/

# Файлы с данными для тестирования
test_data/
sample_files/
```

**Рекомендации по настройке .gitignore:**
- Адаптируйте базовый шаблон под конкретный проект
- Добавляйте новые правила по мере необходимости
- Избегайте слишком общих правил, которые могут исключить нужные файлы
- Проверяйте, что все конфиденциальные данные исключены из репозитория

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Не коммитьте конфиденциальные данные</b></summary>

Никогда не коммитьте в репозиторий:
- Пароли, токены и учетные данные
- Приватные ключи и сертификаты
- Локальные конфигурационные файлы с чувствительными данными
- Временные и логи-файлы
- Тестовые данные с конфиденциальной информацией

**Что делать, если конфиденциальные данные случайно попали в репозиторий:**
1. Немедленно измените все скомпрометированные учетные данные
2. Используйте `git filter-branch` или BFG Repo-Cleaner для удаления данных из истории
3. Создайте новую историю и используйте `git push --force`
4. Обновите .gitignore, чтобы предотвратить повторение ситуации

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Документируйте изменения для релизов (Скорее всего на удаление, возможно избыточно)</b></summary>

Поддержание актуальной документации об изменениях (changelog) упрощает отслеживание внесенных модификаций и планирование развертывания.

**Рекомендации по ведению changelog:**
1. **Форматирование**: используйте стандартизированный формат (например, [Keep a Changelog](https://keepachangelog.com/))
2. **Версионирование**: следуйте Semantic Versioning (MAJOR.MINOR.PATCH)
3. **Группировка изменений** по типам:
- Added (добавлено)
- Changed (изменено)
- Deprecated (устарело)
- Removed (удалено)
- Fixed (исправлено)
- Security (безопасность)

**Пример структуры CHANGELOG.md:**
```markdown
# История изменений

## [1.2.0] - 2023-06-15
### Добавлено
- Поддержка нового формата счетов от поставщика XYZ
- Автоматическая проверка дубликатов документов

### Изменено
- Оптимизирован процесс обработки транзакций для повышения скорости

### Исправлено
- Корректное закрытие соединений с базой данных при возникновении ошибок
- Обработка случаев с отсутствующими датами в документах

## [1.1.0] - 2023-05-10
### Добавлено
...
```

**Интеграция changelog с процессом разработки:**
- Обновляйте changelog при подготовке Pull Request
- Включайте обновление changelog как часть проверки при ревью
- Используйте автоматизированные инструменты для генерации changelog на основе коммитов

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте тегирование для версий (Скорее всего на удаление, возможно избыточно)</b></summary>

Тегирование в Git позволяет отмечать важные точки в истории проекта, такие как релизы или значимые обновления.

**Рекомендации по тегированию:**
1. **Форматирование тегов:**
   - Используйте семантическое версионирование: `v1.0.0`, `v2.3.1`
   - Для релиз-кандидатов: `v1.0.0-rc.1`, `v1.0.0-rc.2`
   - Для бета-версий: `v1.0.0-beta`

2. **Аннотированные теги** предпочтительнее легких:
   ```
   git tag -a v1.0.0 -m "Релиз версии 1.0.0"
   ```

3. **Включайте информативное сообщение** с описанием основных изменений

4. **Синхронизируйте теги с удаленным репозиторием:**
   ```
   git push origin v1.0.0
   ```
   или для всех тегов:
   ```
   git push origin --tags
   ```

5. **Связывайте теги с релизами** в вашей системе управления проектами

**Процесс создания новой версии:**
1. Обновите номер версии в проекте
2. Обновите changelog
3. Создайте коммит с изменениями версии
4. Создайте тег для новой версии
5. Отправьте изменения и тег в репозиторий
6. Создайте релиз в системе управления проектами

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b> (МОЖНО) Используйте вкладку "Проекты" в PIX Master для контроля версий</b></summary>

Помимо системы контроля версий Git, PIX RPA предоставляет встроенный механизм версионирования через вкладку "Проекты" в PIX Master.

**Преимущества использования вкладки "Проекты":**
- Нативная интеграция с платформой PIX RPA
- Не требует дополнительной настройки Git и хостинга репозиториев
- Упрощенный процесс сохранения и возврата к предыдущим версиям
- Доступно всем пользователям без необходимости обучения работе с Git

**Сценарии использования:**
1. **Быстрая разработка** небольших роботов одним разработчиком
2. **Создание контрольных точек** перед значительными изменениями
3. **Командная разработка** при ограниченном доступе к системам контроля версий
4. **Резервное копирование** проектов параллельно с Git

**Рекомендации по использованию:**
1. **Создавайте новую версию** после каждого значимого изменения
2. **Добавляйте описательные комментарии** к версиям для отслеживания изменений
3. **Следуйте стандартам именования** версий (например, семантическое версионирование)
4. **Периодически экспортируйте** проекты для резервного копирования

**Ограничения по сравнению с Git:**
- Отсутствие механизма веток для параллельной разработки
- Ограниченный контроль конфликтов при слиянии изменений
- Нет инструментов для профессионального код-ревью

**Рекомендации для гибридного подхода:**
Для оптимального управления версиями рассмотрите комбинирование Git и встроенного механизма версионирования PIX Master:
1. Используйте Git для полноценного контроля версий и командной разработки
2. Применяйте вкладку "Проекты" для быстрых контрольных точек и резервного копирования
3. Экспортируйте критически важные версии из PIX Master и сохраняйте их в Git-репозитории

**[⬆ К началу статьи](#в-этой-статье)**

</details>

## Соглашение об именовании

Единые соглашения об именовании в проектах PIX RPA значительно упрощают разработку, поддержку и взаимодействие между членами команды. Правильное именование компонентов помогает быстрее понимать код и снижает количество ошибок.

<details>
    <summary><b>Используйте PascalCasing для параметров скриптов</b></summary>

Используйте регистр Pascal Case (первая буква каждого слова заглавная, без разделителей) при именовании параметров скрипта. Добавляйте соответствующие префиксы для обозначения типа параметра:

- `In_` для входных параметров (например, `In_CustomerId`)
- `Out_` для выходных параметров (например, `Out_ProcessingResult`)
- `InOut_` для параметров, которые являются одновременно входными и выходными (например, `InOut_TransactionStatus`)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте camelCasing для локальных переменных</b></summary>

Используйте регистр camel Case (первая буква строчная, первые буквы следующих слов заглавные) при именовании локальных переменных в скриптах.

**Преимущества:**
- Визуальное отличие локальных переменных от параметров скрипта
- Соответствие общепринятым стандартам C#
- Улучшенная читаемость и структурированность кода

**Последствия несоблюдения:**
- Смешение стилей затрудняет понимание области видимости переменных
- Снижение читаемости кода
- Усложнение поддержки и модификации существующего кода

![camelCasing](/common/camelCasing.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте осмысленные и информативные имена</b></summary>

Всегда давайте переменным, параметрам и функциям имена, которые ясно отражают их назначение и контекст использования.

**Хорошие примеры:**
- `customerInvoiceFilePath` вместо просто `path`
- `isTransactionCompleted` вместо `flag` или `status`
- `employeeCount` вместо `num` или `n`

**Последствия использования абстрактных имен:**
- Снижение читаемости кода
- Увеличение времени на анализ и понимание логики
- Повышение риска ошибок при использовании переменных
- Затруднение отладки и поддержки

**Исключения:** 
Для индексов в коротких циклах допустимо использовать однобуквенные переменные (`i`, `j`, `k`), но только в рамках локального контекста и небольших блоков кода. Никогда не используйте такие переменные как параметры скриптов.

![MeaningfulNames](/common/domainName.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Соблюдайте конвенции нейминга языка и компании</b></summary>

Придерживайтесь общепринятых правил именования в C# и соглашений, принятых в вашей компании. Это обеспечивает преемственность и совместимость с существующими проектами и библиотеками.

**Преимущества:**
- Сокращение времени на адаптацию новых разработчиков
- Единообразие кодовой базы

**Последствия несоблюдения:**
- Рассогласованность в кодовой базе
- Увеличение времени на обучение новых членов команды
- Увеличение времени на передачу проекта другому сотрудники или команде поддержки

Ссылки на официальные руководства:
- [Правила и соглашения об именовании C#](https://learn.microsoft.com/ru-ru/dotnet/csharp/fundamentals/coding-style/identifier-names)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте устоявшиеся термины для общих понятий</b></summary>

Выбирайте один термин для обозначения каждого понятия и придерживайтеся его во всем проекте. Избегайте использования синонимов, которые могут вызвать путаницу.

**Примеры стандартизации терминов:**
- Поставщик: использовать `supplier` (а не provider, vendor, contractor)
- Заказчик: использовать `customer` (а не client, consumer)
- Цена: использовать `price` (а не rate, cost, pricing, worth)
- Объем: использовать `volume` (а не amount, size, bulk, quantity)
- Склад: использовать `warehouse` (а не storage, store, storehouse)

**Преимущества:**
- Единообразие терминологии во всем проекте
- Снижение когнитивной нагрузки при чтении кода
- Улучшение понимания предметной области

**Последствия несоблюдения:**
- Путаница в терминологии
- Сложности при коммуникации в команде

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Не используйте кириллицу в именах</b></summary>

Используйте только ASCII-символы (латиницу) для имен переменных, функций и параметров.

**Преимущества:**
- Совместимость со всеми средами разработки и системами контроля версий
- Соответствие индустриальным стандартам
- Отсутствие проблем с кодировками

**Последствия использования кириллицы:**
- Возможные ошибки кодировки в различных средах

![ruCharts](/common/ruCharts.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте венгерской нотации</b></summary>

Венгерская нотация (добавление префикса типа к имени переменной) избыточна в современных средах разработки с поддержкой типизации и подсказок IDE.

**Примеры:**
- Не используйте: `strName`, `intAge`, `boolIsActive`
- Используйте: `name`, `age`, `isActive`

**Преимущества отказа от венгерской нотации:**
- Более чистый и читаемый код
- Легкость рефакторинга при изменении типа переменной
- Соответствие современным практикам разработки

**Последствия использования венгерской нотации:**
- Избыточность информации
- Сложности при изменении типов данных

![FixHungarianNotation](/common/FixHungarianNotation.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте избыточных названий</b></summary>

Не дублируйте информацию, которая уже очевидна из контекста или типа переменной.

**Преимущества лаконичных имен:**
- Более компактный и читаемый код
- Сокращение визуального шума
- Фокус на смысловой составляющей имени

**Последствия избыточности:**
- Увеличение длины кода без добавления ценности
- Снижение читаемости
- Потеря внимания к действительно важным аспектам кода

![Context](/common/Context.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте контекстуально понятные имена</b></summary>

Контекст использования переменной должен быть очевиден из её имени. Избегайте общих терминов без уточнения.

**Примеры улучшения контекста:**
- `filePath` вместо просто `path`
- `invoiceStatus` вместо просто `status`
- `paymentMethod` вместо просто `method`
- `customerEmail` вместо просто `email`
- `documentCreationDate` вместо просто `date`
- `orderConfirmationMessage` вместо просто `message`
- `employeeFirstName` вместо просто `name`
- `transactionAmount` вместо просто `value`
- `errorMessageText` вместо просто `text`
- `invoiceDownloadUrl` вместо просто `url`

**Преимущества контекстуальных имен:**
- Ясность назначения и использования переменной
- Уменьшение зависимости от комментариев
- Снижение когнитивной нагрузки при чтении кода

**Последствия отсутствия контекста:**
- Необходимость постоянно держать в уме контекст использования переменной
- Сложности при рефакторинге
- Увеличение вероятности ошибок при использовании

![NotContext](/common/NotContext.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте абстрактных названий</b></summary>

Название переменной должно ясно передавать её назначение и ожидаемые значения, а не просто обозначать действие.

**Примеры:**
- `isEmailValid` вместо `checkEmail`
- `hasAttachments` вместо `checkAttachments`
- `isAuthorized` вместо `authorizationCheck`
- `canUserEdit` вместо `verifyEditPermission`
- `isAccountActive` вместо `accountStatusCheck`
- `hasUnreadMessages` вместо `checkMessages`
- `isFileUploaded` вместо `uploadFileStatus`
- `areCredentialsValid` вместо `validateCredentials`
- `isRequestSuccessful` вместо `requestResult`
- `hasExpired` вместо `expirationCheck`

**Преимущества конкретных имен:**
- Однозначность в понимании ожидаемого результата
- Возможность использования переменной в условных выражениях без дополнительных пояснений
- Самодокументирующийся код

**Последствия абстрактных названий:**
- Неоднозначность в интерпретации значений
- Необходимость изучения реализации для понимания назначения
- Повышенный риск неправильного использования

![Abstract](/common/Abstract.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте отрицательных переменных</b></summary>

Логические переменные с отрицанием в названии затрудняют понимание условных выражений и повышают вероятность ошибок.

**Примеры:**
- Используйте `isValid` вместо `isNotInvalid`
- Используйте `isCompleted` вместо `isNotPending`
- Используйте `hasAccess` вместо `isNotForbidden`
- Используйте `isEnabled` вместо `isNotDisabled`
- Используйте `isAvailable` вместо `isNotUnavailable`
- Используйте `isIncluded` вместо `isNotExcluded`
- Используйте `isApproved` вместо `isNotRejected`
- Используйте `isEmpty` вместо `isNotFilled`
- Используйте `canProceed` вместо `isNotBlocked`
- Используйте `isAllowed` вместо `isNotProhibited`

**Преимущества позитивных формулировок:**
- Интуитивно понятные условные выражения
- Снижение когнитивной нагрузки при чтении кода
- Уменьшение вероятности логических ошибок в условиях

**Последствия использования отрицаний:**
- Запутанные условные выражения с двойным отрицанием
- Повышенная вероятность ошибок при изменении условий
- Сложности при чтении и понимании логики

![NotVariables](/common/NotVariables.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

## Соглашение о БД

Правильный подход к работе с базами данных в PIX RPA проектах позволяет значительно повысить производительность роботов, уменьшить потребление ресурсов и сделать решения более надежными.

<details>
    <summary><b>Используйте Bulk запросы</b></summary>

Для добавления или обновления большого количества записей в БД используйте bulk операции вместо циклов с одиночными запросами.

**Преимущества Bulk запросов:**
- Только один запрос к базе данных вместо множества одиночных
- Существенное ускорение операций с большими наборами данных
- Снижение нагрузки на сеть и СУБД
- Сокращение ресурсов, необходимых для транзакций

**Пример сравнения производительности:**

|Кол-во записей|Обычный запрос (Insert)|Bulk-запрос (bulk insert)|Ускорение|
|-:|:-:|:-:|:-:|
|100|2 мс|1,9 мс|~5%|
|1 000|18 мс|8 мс|~125%|
|10 000|203 мс|76 мс|~167%|
|100 000|2,13 с|742 мс|~187%|
|1 000 000|21,56 с|8,3 с|~160%|

*Тестовая таблица содержит 6 столбцов (Guid, string x2, int, decimal?, DateTime)*  
*Конфигурация тестового окружения:*
- CPU INTEL i7-10510U с частотой 2,30 ГГц
- RAM DDR3 16 ГБ
- SSD SAMSUNG 512 ГБ

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Выполняйте фильтрацию в SQL-запросах, а не в коде</b></summary>

Всегда переносите логику фильтрации данных в SQL-запросы вместо загрузки всего набора данных и последующей фильтрации в коде.

**Преимущества фильтрации на уровне SQL:**
- Значительное снижение объема передаваемых данных
- Меньшее потребление оперативной памяти
- Использование оптимизированных механизмов БД для обработки данных
- Повышение скорости выполнения операций

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте создания хранимых процедур в БД</b></summary>

В проектах PIX RPA рекомендуется избегать создания хранимых процедур и размещать всю логику работы с данными в коде робота.

**Преимущества отказа от хранимых процедур:**
- Полный контроль логики внутри робота
- Упрощение процесса разработки и отладки
- Снижение зависимости от администраторов БД при внесении изменений
- Возможность легкого переноса логики между средами
- Улучшение версионирования кода (вся логика в одном репозитории)
- Упрощение управления доступами (не требуются права на создание объектов в БД)

**Когда можно использовать хранимые процедуры:**
- При наличии централизованной бизнес-логики, используемой несколькими системами
- Когда требуется сложная обработка с минимальной передачей данных
- Если существуют строгие требования безопасности к прямому доступу к таблицам

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Корректно работайте с NULL и пустыми строками</b></summary>

При работе с базами данных важно понимать разницу между NULL и пустой строкой ('') и использовать их в соответствии с бизнес-логикой.

**Основные принципы:**
- **NULL** используется, когда значение отсутствует или неизвестно
- **Пустая строка ('')** используется, когда значение известно, но пусто

**Примеры правильного использования:**

1. **Использование NULL:**
- Необязательное поле не заполнено пользователем
- Данные еще не получены или не обработаны
- Значение не существует в контексте записи

2. **Использование пустой строки (''):**
- Поле было заполнено, но содержит пустое значение
- Результат обработки или распознавания был пустым
- Пользователь явно оставил поле пустым (не NULL)

**Типичные ошибки:**
- Сравнение с NULL через оператор "==" вместо IS NULL в SQL
- Использование пустой строки для представления отсутствующих данных
- Неправильная обработка NULL в условиях и проверках

**[⬆ К началу статьи](#в-этой-статье)**

</details>

## Соглашение об очередях

Очереди в PIX Master — это мощный инструмент для организации параллельной обработки данных и масштабирования роботов. Правильное использование очередей значительно повышает отказоустойчивость и эффективность автоматизации.

**Основные принципы работы с очередями:**
- Очереди позволяют распределять нагрузку между несколькими экземплярами роботов
- Элементы очереди сохраняют состояние между запусками роботов
- Возможность обработки исключений и повторного запуска проблемных элементов

<details>
    <summary><b>Понимайте особенности очередей в PIX Master</b></summary>

В PIX Master реализован единый тип очередей, который хранится в базе данных:
- Доступны через API и активности робота
- Поддерживают операции мониторинга и аналитики
- Обеспечивают согласованное состояние между различными экземплярами роботов

**Преимущества очередей в PIX Master:**
- Централизованное управление данными для обработки
- Встроенная отказоустойчивость и механизмы восстановления
- Поддержка параллельной обработки несколькими роботами
- Возможность мониторинга и аналитики процессов обработки

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Выбирайте оптимальный формат данных для элементов очереди</b></summary>

В PIX Master данные в элементах очереди можно хранить в различных форматах, каждый из которых имеет свои преимущества и ограничения:

1. **Dictionary (C#):**
- **Рекомендуемый формат** для большинства сценариев в PIX RPA
- Подходит для коллекций ключ-значение с простой структурой
- Обеспечивает быстрый и простой доступ к данным по ключу
- Не требует сложной сериализации/десериализации
- Работает "из коробки" без дополнительных библиотек

2. **DataTable (C#):**
- Оптимален для табличных данных с чёткой структурой строк и столбцов
- Удобен для обработки больших наборов однотипных записей
- Предоставляет встроенные методы для фильтрации и обработки данных
- Эффективен при работе с данными из баз данных и Excel
- Хорошо поддерживается стандартными активностями PIX RPA

3. **JSON-строки:**
- Подходит для обмена данными с внешними системами
- Поддерживает текстовое представление данных
- **Ограничения в PIX RPA:**
    - Сложности с парсингом и созданием вложенных структур без пользовательских классов
    - Рекомендуется использовать только для простых структур
    - Для сложных данных предпочтительнее Dictionary или DataTable

**Рекомендации по выбору формата в PIX RPA:**
- Используйте **Dictionary** как основной формат для большинства сценариев
- Применяйте **DataTable** для табличных данных и при работе с Excel/базами данных
- Используйте **JSON** только для простых структур или когда требуется совместимость с внешними системами
- Избегайте сложных вложенных JSON-структур из-за ограничений парсинга в PIX RPA

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Обновляйте статус элементов очереди в правильном порядке</b></summary>

Элементы очереди обновляйте в последнюю очередь, после того как все данные сохранены и обработка транзакции полностью завершена.

**Преимущества:**
- Предотвращение потери данных в случае сбоя системы
- Обеспечение целостности данных
- Упрощение восстановления после сбоев

**Последствия несоблюдения:**
- Риск пометить элемент как обработанный до завершения всех связанных операций
- Сложности при восстановлении после сбоев
- Возможность создания дубликатов и потери данных

**Правильный порядок действий:**
1. Получение элемента из очереди (статус "В обработке")
2. Полная обработка данных и сохранение результатов в целевые системы
3. Проверка успешности всех операций
4. Обновление статуса элемента очереди ("Успешно" или "Ошибка")

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте информативные сообщения в статусах очередей</b></summary>

Статусы элементов очереди должны содержать краткую, но информативную информацию о состоянии обработки. В случае ошибки добавляйте ключевую информацию об ошибке.

**Пример информативных сообщений:**
- "Счет успешно создан: INV-12345"
- "Ошибка обработки: данные клиента не найдены"
- "Отложено: ожидание подтверждения от системы XYZ"

**Преимущества:**
- Упрощение мониторинга и анализа производительности
- Ускорение диагностики проблем
- Облегчение ручной обработки исключений

**Структура информативного сообщения об ошибке:**
1. Краткое описание ошибки (1-2 слова)
2. Контекст операции
3. Ключевая информация для исправления (если применимо)

**Пример:** "Ошибка API: создание клиента. Код 403: недостаточно прав"

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Правильно обрабатывайте повторные попытки (retry)</b></summary>

Механизм повторных попыток позволяет роботам эффективно справляться с временными сбоями.

**Рекомендации:**
- Используйте встроенный механизм повторных попыток в оркестраторе
- Чётко разделяйте временные и постоянные ошибки
- Устанавливайте разумное количество повторных попыток (обычно 3-5)
- Используйте экспоненциальную задержку между попытками

**Временные ошибки (подходят для retry):**
- Сетевые таймауты
- Временная недоступность API
- Блокировки в базе данных
- Кратковременные сбои в работе внешних систем

**Постоянные ошибки (не подходят для retry):**
- Отсутствие необходимых данных
- Неверный формат входных данных
- Ошибки авторизации и доступа
- Логические ошибки в данных

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте транзакционный подход при работе с очередями (В работе)</b></summary>

Обработка элементов очереди должна следовать транзакционному подходу для обеспечения целостности данных.

**Основные принципы:**
- Каждый элемент очереди обрабатывается как атомарная транзакция
- В случае сбоя вся транзакция откатывается (если возможно) или регистрируется для ручной обработки
- Статус элемента очереди отражает статус всей транзакции

**Рекомендации:**
- Используйте паттерн "Сохранение данных → Обновление очереди"
- В случае сбоя при сохранении данных, не обновляйте статус элемента очереди
- Сохраняйте контрольные точки для сложных многошаговых процессов
- Реализуйте механизм компенсации для отката частично выполненных операций

**Преимущества транзакционного подхода:**
- Гарантия целостности данных между системами
- Предотвращение дублирования или потери данных
- Упрощение восстановления после сбоев
- Повышение надежности системы в целом

**[⬆ К началу статьи](#в-этой-статье)**

</details>

## Соглашение о логировании

Эффективное логирование - ключевой элемент успешного выполнения и сопровождения RPA-роботов. В PIX RPA часть информации логируется автоматически, но правильная настройка пользовательского логирования существенно упрощает отладку, мониторинг и поддержку роботов.

**Основные цели логирования в RPA-проектах:**
- **Диагностика проблем** — быстрое определение причин сбоев
- **Мониторинг производительности** — анализ времени выполнения процессов
- **Аудит действий** — отслеживание критичных бизнес-операций
- **Сбор метрик** — данные для оптимизации процессов

**Что не следует логировать:**
- Информацию, которая уже логируется платформой PIX RPA автоматически
- Конфиденциальные данные (пароли, персональные данные, коммерческую информацию)
- Избыточную информацию, создающую "информационный шум"
- Полные стеки вызовов в часто повторяющихся операциях

<details>
    <summary><b>Логируйте прогресс обработки (В работе)</b></summary>

При обработке массивов данных важно логировать текущий прогресс для понимания состояния выполнения и оценки оставшегося времени.

**Рекомендации:**
- Для крупных массивов (более 100 элементов) логируйте прогресс в процентах (10%, 20%, ...)
- Используйте формат "обработано X из Y элементов" для большей информативности
- Логируйте через равные интервалы (например, каждые 10% или 100 элементов)
- Избегайте слишком частого логирования при небольших объемах данных


**Пример: //Пока пример на C# будут примеры скриптов**
```csharp
// Эффективное логирование прогресса
var totalItems = dataTable.Rows.Count;
var logStep = Math.Max(1, totalItems / 10); // Логируем каждые 10%

for (int i = 0; i < totalItems; i++)
{
    // Обработка элемента
    ProcessItem(dataTable.Rows[i]);
    
    // Логирование прогресса с интервалами
    if (i % logStep == 0 || i == totalItems - 1)
    {
        var percentage = (int)Math.Round((double)(i + 1) / totalItems * 100);
        Logger.Info($"Прогресс обработки: {percentage}% ({i + 1} из {totalItems})");
    }
}
```

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Правильно логируйте исключения (В работе)</b></summary>

Исключения должны логироваться так, чтобы содержать достаточно информации для диагностики, но не создавать избыточных записей.

**Рекомендации:**
- Логируйте контекст, в котором произошла ошибка (идентификатор транзакции, этап процесса)
- Включайте сообщение и тип исключения, а также ключевую информацию из внутренних исключений
- Не дублируйте информацию, которая уже логируется платформой PIX RPA
- Избегайте логирования полных трейсов исключений элементы очередей мастера

**Пример эффективного логирования исключений://Пока пример на C# будут примеры скриптов**
```csharp
try
{
    // Код, который может вызвать исключение
    ProcessInvoice(invoiceId);
}
catch (Exception ex)
{
    // Логируем с контекстом, но без полного стека вызовов
    var innerMsg = ex.InnerException != null ? $" Внутренняя ошибка: {ex.InnerException.Message}" : "";
    Logger.Error($"Ошибка при обработке счета {invoiceId}. Тип: {ex.GetType().Name}. Сообщение: {ex.Message}.{innerMsg}");
    
    // Перебрасываем исключение для обработки на более высоком уровне
    throw;
}
```

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте подходящие уровни логирования</b></summary>

В PIX RPA фактические уровни логирования смещены относительно традиционных из-за того, что начало и конец выполнения скриптов автоматически логируются на уровне INFO.

**Важно**: Из-за особенностей логирования в PIX RPA стандартная иерархия уровней смещается:
- **ERROR** сохраняет своё предназначение
- **WARNING** фактически соответствует уровню INFO в традиционном понимании 
- **INFO** фактически соответствует уровню DEBUG в традиционном понимании
- Уровни **DEBUG** и **TRACE** в production практически не используются

**Рекомендуемые уровни в PIX RPA:**
- **ERROR** — критические ошибки, требующие вмешательства или прерывающие выполнение
- **WARNING** — важные бизнес-события и ключевые этапы процесса (используйте для значимой информации)
- **INFO** — детальная техническая информация, промежуточные этапы и диагностические сообщения
- **DEBUG** — очень подробная отладочная информация (не используйте в production)

**Особенности использования уровней в PIX RPA:**
- Поскольку системная информация уже логируется на уровне INFO, используйте для своих значимых сообщений уровень WARNING
- Для диагностических и детальных сообщений используйте уровень INFO
- В production среде обычно настраивается просмотр только уровней ERROR и WARNING
- Уровень INFO включайте только при детальной диагностике проблем

**Типичные сценарии использования:**
- **ERROR**: "Не удалось подключиться к API после 3 попыток", "Транзакция отклонена: недостаточно средств"
- **WARNING**: "Успешно обработана транзакция #12345", "Загружено 100 записей из БД", "Полностью сформирован пакет документов"
- **INFO**: "Начата обработка элемента #42", "Параметры запроса к API: {параметры}", "Результат проверки формата: допустимый"
- **DEBUG**: Крайне детальная информация о внутренних операциях (практически не используется)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте избыточного логирования</b></summary>

Избыточное логирование создает "информационный шум" и усложняет анализ логов.

**Не рекомендуется логировать:**
- События начала и конца скриптов (PIX RPA уже логирует эту информацию)
- Техническую информацию о вызовах методов без бизнес-контекста
- Подробности каждой итерации в цикле (кроме прогресса)
- Успешные стандартные операции, которые редко вызывают проблемы

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Логируйте метрики производительности (если нужно собирать метрики внутри робота)</b></summary>

Для оптимизации роботов важно собирать данные о времени выполнения ключевых операций.

**Рекомендации:**
- Измеряйте и логируйте время выполнения длительных операций
- Отслеживайте количественные показатели (обработано документов, ошибок и т.д.)
- Используйте консистентный формат для упрощения автоматизированного анализа

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Защищайте конфиденциальные данные</b></summary>

Особое внимание необходимо уделять защите конфиденциальной информации при логировании.

**Никогда не логируйте:**
- Пароли и ключи доступа
- Полные номера кредитных карт (можно только последние 4 цифры)
- Персональные данные (ФИО, даты рождения, адреса)
- Медицинскую информацию и другие защищаемые законом данные
- Коммерческую тайну и внутреннюю информацию компании

**Методы защиты чувствительных данных:**
- Маскирование: `"Номер карты: ****1234"`
- Хеширование: `"Клиент: " + GetHashValue(customerData)`
- Сокращение: `"Email: j***@example.com"`

**[⬆ К началу статьи](#в-этой-статье)**

</details>

## Соглашение об исключениях

<details>
    <summary><b>Избегайте появления 'Exception has been thrown by the target of an invocation.'</b></summary>

Некоторые ошибки в PIX выбрасывают исключение с текстом 'Exception has been thrown by the target of an invocation'. На самом деле, настоящая ошибка указана в InnerException данного исключения.

Пример вызова исключения NullReferenceException

![Exception1](/common/Exception1.png)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Не генерируйте исключения повторно</b></summary>

// В работе

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Не оставляйте Catch пустым и не используйте Try/Catch/Finally в бизнес-логике</b></summary>

Пустые блоки Catch создают иллюзию обработки ошибок, а Try/Catch в бизнес-логике приводит к запутанному коду и снижению производительности.

**Проблемы пустых блоков Catch:**
- Скрывают ошибки, делая их обнаружение невозможным
- Оставляют систему в неопределенном состоянии
- Усложняют отладку и поиск источника проблем
- Создают ложное впечатление, что ошибка обработана

**Проблемы использования Try/Catch в бизнес-логике:**
- Код становится сложнее для понимания и поддержки
- Снижается производительность (обработка исключений ресурсоемка, но в рамках простых роботов не критично)
- Смешиваются нормальный поток выполнения и обработка ошибок
- Исключения используются для контроля потока выполнения

**Типичный антипаттерн: конвертация строки в DateTime через исключения //Пока пример на C# будут примеры скриптов**

**Неправильно:**
```csharp
public DateTime ConvertToDateTime(string dateStr)
{
    try
    {
        // Пробуем сначала формат дд.мм.гггг
        return DateTime.ParseExact(dateStr, "dd.MM.yyyy", CultureInfo.InvariantCulture);
    }
    catch
    {
        try
        {
            // Если не получилось, пробуем мм/дд/гггг
            return DateTime.ParseExact(dateStr, "MM/dd/yyyy", CultureInfo.InvariantCulture);
        }
        catch
        {
            // Если и так не получилось, возвращаем значение по умолчанию
            // При этом не учитывается, что это может быть любой другой формат
            // и в логах PIX RPA будет отображаться ошибка, хотя это нормальный путь исполнения
            return DateTime.MinValue;
        }
    }
}
```

**Правильно:**
```csharp
public DateTime ConvertToDateTime(string dateStr)
{
    if (string.IsNullOrEmpty(dateStr))
    {
        return DateTime.MinValue;
    }
    
    // Определяем массив возможных форматов
    string[] formats = { "dd.MM.yyyy", "MM/dd/yyyy", "yyyy-MM-dd" };
    
    DateTime result;
    if (DateTime.TryParseExact(
        dateStr, 
        formats,
        CultureInfo.InvariantCulture,
        DateTimeStyles.None, 
        out result))
    {
        return result;
    }
    
    // Если ни один формат не подошел
    return DateTime.MinValue; // или можно выбросить бизнес-исключение
}
```

**Антипаттерн: использование исключений для проверки существования файлов //Пока пример на C# будут примеры скриптов**

**Неправильно:**
```csharp
public void SaveDataToFile(string filePath, string data)
{
    try
    {
        // Пытаемся записать данные в файл напрямую
        File.WriteAllText(filePath, data);
    }
    catch (DirectoryNotFoundException)
    {
        // Если директория не существует, создаем её и пробуем снова
        // В логах PIX RPA при этом будет ошибка, хотя это ожидаемый сценарий
        Directory.CreateDirectory(Path.GetDirectoryName(filePath));
        File.WriteAllText(filePath, data);
    }
}
```

**Правильно:**
```csharp
public void SaveDataToFile(string filePath, string data)
{
    // Проверяем существование директории перед записью
    string directory = Path.GetDirectoryName(filePath);
    if (!Directory.Exists(directory))
    {
        Directory.CreateDirectory(directory);
    }
    
    // Теперь безопасно записываем данные без риска получить исключение
    File.WriteAllText(filePath, data);
}
```

**Важные рекомендации по работе с UI в PIX RPA:**
1. **Используйте активности поиска элемента** вместо try/catch
2. **Настраивайте разумные таймауты** для поиска элементов
3. **Разделяйте логику поиска элементов** и взаимодействия с ними (если элементы динамичные)
4. **Создавайте четкие селекторы**, чтобы минимизировать ошибки поиска

**Важно для PIX RPA:** Платформа автоматически логирует все исключения, даже те, которые перехватываются в блоках catch. Это создает лишние записи в логах и может дезинформировать при анализе проблем. Когда вы используете try/catch для контроля потока выполнения, в логах появляются ошибки, хотя фактически это может быть нормальный сценарий выполнения.

**Рекомендации:**
1. **Вместо Try/Catch используйте функции с префиксом Try-:**
- `DateTime.TryParse()` и `DateTime.TryParseExact()` вместо `DateTime.Parse()` в блоке try-catch
- `int.TryParse()` вместо `Convert.ToInt32()` в блоке try-catch
- `Dictionary.TryGetValue()` вместо доступа по ключу в блоке try-catch

2. **Для файловых операций используйте проверки вместо исключений:**
- `File.Exists()` перед `File.ReadAllText()`
- `Directory.Exists()` перед `Directory.GetFiles()`
- `Directory.CreateDirectory()` создаст директорию, если она не существует (не выбрасывает исключений)

3. **Для сетевых операций:**
- Проверяйте соединение перед отправкой запроса
- Используйте таймауты и повторные попытки вместо простого перехвата исключений

4. **В сложных алгоритмах:**
- Проверяйте граничные условия и недопустимые значения в начале метода
- Применяйте паттерн Guard Clause для раннего выхода из метода

**Когда допустимо использовать try-catch:**
- Внешний уровень приложения для глобальной обработки ошибок
- Взаимодействие с внешними системами, где ошибки непредсказуемы
- Работа с неуправляемыми ресурсами (в сочетании с блоком finally)
- Специфические сценарии, где ошибка — это ожидаемая часть бизнес-логики

Исключения должны использоваться для обработки **исключительных ситуаций**, а не для обычного контроля потока выполнения программы.

**[⬆ К началу статьи](#в-этой-статье)**

</details>

## Рекомендации по написанию скриптов

<details>
    <summary><b>Соблюдайте соглашение о коде C#</b></summary>

Стандарт кода необходим для поддержания удобочитаемости кода, согласованности и совместной работы в команде разработчиков. Код, который соответствует отраслевым методикам и установленным рекомендациям, проще понимать, поддерживать и расширять. Большинство проектов применяют согласованный стиль с помощью соглашений о коде. И dotnet/docsdotnet/samples проекты не являются исключением. В этой серии статей вы узнаете о наших соглашениях по программированию и средствах, которые мы используем для их применения. Вы можете принять наши соглашения как есть или изменить их в соответствии с потребностями вашей команды.

[Общие соглашение о коде C#](https://learn.microsoft.com/ru-ru/dotnet/csharp/fundamentals/coding-style/coding-conventions)

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Соблюдайте SRP (SOLID) (Будет переделан, нет смысла говорить о SOLID в роботах)</b></summary>

SRP – принцип единой ответственности. Этот принцип означает, что каждый скрипт в вашем коде должен выполнять одну операцию.<p>

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Соблюдайте принцип DRY</b></summary>

DRY – Don't repeat yourself (не повторяй себя). Всегда думайте о том, как можно переиспользовать тот или иной фрагмент скрипта. Что можно выделить в универсальный скрипт/функцию. Речь не идет о написании активностей - я имею в виду очень похожею логику, которая встречается в нескольких местах.

*Есть еще принипы KISS, YAGNI:<p>
KISS - Keep it simple, stupid ("Сделай это проще, тупица") - "чем проще - тем лучше", но это не означает сделать быстро и кое как<p>
YAGNI - "тебе это не нужно", не прописывай функции, которые могут и не понадобиться в будущем*


**[⬆ К началу статьи](#в-этой-статье)**

</details>


<details>
    <summary><b>Используйте минимальное кол-во аргументов</b></summary>

- Меньше - лучше
- Если скрипт принимает слишком много аргументов, возможно он нарушает SRP
- Большое кол-во аргументов - проблемы с тестированием
- Большое кол-во аргументов возможно стоит завернуть в объект(например словарь)
<p>

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте $,@,""" при работе со строками</b></summary>

- [Строковые литералы verbatim](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/strings/#verbatim-string-literals)
- [Необработанные строковые литералы (Скоро появится в PIX)](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/strings/#raw-string-literals)
- [Интерполяция строк](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/strings/#string-interpolation)


**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте LINQ</b></summary>

Используйте LINQ вместо циклов и встроенных активностей при работе с коллекциями<p>

<b>Чек-лист По LINQ</b>

- Понимать разницу между IEnumerable и IQueryable
- Фильтровать (Where()) данные как можно раньше в цепочке вызовов.
- Извлекать (Select()) только нужные поля, а не всю сущность.
- Использовать Any() вместо Count() > 0 для проверки наличия элементов.
- Избегать многократных проходов по коллекции (повторных .Where(), .Select())
- Знать разницу между отложенным и немедленным выполнением.
- Не использовать Where().FirstOrDefault() – просто FirstOrDefault().
- Вызывать Where() перед Select(), а не наоборот.
- Использовать FirstOrDefault(predicate), если проверяется только одно значение.
- Использовать ?? для значений, которые могут быть null.
- Использовать DefaultIfEmpty() при GroupBy().
- Использовать Distinct() для уникальных значений.
- Использовать Union() для объединения без дубликатов.
- Использовать Except() и Intersect() для разницы между коллекциями.

<b>Плюсы</b>

- Компактный, умещается в одну активность
- Упрощает понимание запроса/алгоритма
- Гибкий, расширяемость и деревья выражений позволяют выполнить любой запрос 
- Наличие методы для паралельной обработки

<b>Минусы</b>

- Сложная отладка больших запросов
- Производительность (for > foreach > LINQ)

<b>Примеры:</b>

![UseLINQ](/common/UseLINQ.png)
![UseLINQ2](/common/UseLINQ2.png)

Исключения:

- При работе с внешними сервисами (файлы, почта, БД,UI)
- Большая бизнес логика

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Дополнительные рекомендации по использованию LINQ</b></summary>

<b>Избегайте повторной обаботки коллекции</b><br>
Повторный вызов методов LINQ, таких как Where, приводит к повторному перебору коллекции.<br>
<b>Решение:</b> кэшируйте результаты, если они используются несколько раз:

```csharp
var filtered = myCollection.Where(x => x.Age > 30).ToList(); // Выполняется один раз
 var count = filtered.Count;
var average = filtered.Average(x => x.Salary);
```


<b>Избегайте использования Count для проверки на пустоту</b><br>
Count перебирает всю коллекцию, что замедляет выполнение.<br>
<b>Решение:</b> используйте Any() вместо Count():<br>

```csharp
if (myCollection.Any()) // Быстрее, чем myCollection.Count() > 0
```


    <b>Параллельное выполнение (PLINQ)</b><br>
    Обработка больших коллекций может быть медленной.<br>
    <b>Решение:</b> используйте PLINQ для параллельного выполнения:<br>
    ```csharp
    var result = myCollection.AsParallel()
    .Where(x => x.IsActive)
    .ToList();
    ```


    <b>Проекционная оптимизация (Select)</b><br>
    Извлечение всех данных, когда требуется только несколько полей.<br>
    <b>Решение:</b> Используйте Select для выборки только необходимых данных:<br>
    ```csharp
    var names = myCollection.Select(x => x.Name).ToList();
    ```


    <b>Фильтрация перед проекцией</b><br>
    Проекция больших объёмов данных перед фильтрацией замедляет запрос.<br>
    <b>Решение:</b> сначала фильтруйте, затем проецируйте:<br>
    ```csharp
    var result = myCollection.Where(x => x.Age > 30)
    .Select(x => x.Name)
    .ToList();
    ```

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте условные операторы</b></summary>

    Использование условных операторов вместо встроенных if активностей, позволяют писать компактные и легко читаемый код

    Операторы с условным ?. значением NULL и ?[]

    ![operator](/common/operator.png)

    Тернарный условный оператор (?: оператор)

    ![operator2](/common/operator2.png)

    в PIX контекстные значения, это свойства в C#, поэтому нельзя использовать out и ref напрямую

    ![operator2_2](/common/operator2_2.png)

    Операторы объединения со значением NULL (?? И?? = операторы)

    ![operator3](/common/operator3.png)

    Исключения:
    - Большая бизнес-логика

    ![operatornotuse](/common/NotUseOperator.png)

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Используйте класс Path для работы с файлами</b></summary>

    Используйте методы из класса Path для работы с путями и файлами вместо ручной манипуляции строками. Класс Path предоставляет безопасные, кроссплатформенные методы для работы с путями к файлам и директориям.

    **Основные методы:**

    - `Path.Combine()` - объединяет две или более строки в путь с учетом разделителей для текущей ОС
    - `Path.GetExtension()` - возвращает расширение файла (включая точку)
    - `Path.GetFileName()` - возвращает имя файла и расширение
    - `Path.GetFileNameWithoutExtension()` - возвращает имя файла без расширения
    - `Path.GetDirectoryName()` - возвращает директорию из полного пути к файлу
    - `Path.GetFullPath()` - возвращает абсолютный путь
    - `Path.GetTempPath()` - возвращает путь к временной папке (особенно важно использовать вместо создания временных папок в жестко заданных путях)
    - `Path.GetTempFileName()` - создает уникальный временный файл и возвращает путь к нему
    - `Path.GetRandomFileName()` - генерирует случайное имя файла, которое можно использовать для создания временных файлов
    - `Path.ChangeExtension()` - изменяет расширение в указанном пути

    **Преимущества использования класса Path:**
    - Кроссплатформенность: код одинаково работает в Windows, Linux и macOS
    - Корректная обработка разделителей пути (слеши) для разных ОС
    - Предотвращение ошибок при ручной конкатенации путей
    - Устранение дублирования кода для типовых операций с путями
    - Повышение читаемости и надежности кода

    **Примеры использования:**

    ```csharp
    // Плохо - ручное объединение путей с жестко заданными разделителями
    string badPath = directory + "\\" + fileName;

    // Хорошо - использование Path.Combine
    string goodPath = Path.Combine(directory, fileName);

    // Плохо - генерация временных файлов в фиксированном месте
    string tempFile = "C:\\Temp\\myTempFile.txt";

    // Хорошо - использование системных методов для временных файлов
    string tempPath = Path.GetTempPath();
    string tempFile = Path.Combine(tempPath, Path.GetRandomFileName());

    // Плохо - ручное извлечение имени файла из пути
    string fileName = fullPath.Substring(fullPath.LastIndexOf('\\') + 1);

    // Хорошо - использование Path.GetFileName
    string fileName = Path.GetFileName(fullPath);

    // Плохо - ручное изменение расширения
    string newPath = oldPath.Substring(0, oldPath.LastIndexOf('.')) + ".bak";

    // Хорошо - использование Path.ChangeExtension
    string newPath = Path.ChangeExtension(oldPath, ".bak");
    ```

    **Последствия несоблюдения:**
    - Проблемы при переносе кода между разными ОС
    - Потенциальные ошибки при объединении путей
    - Отсутствие унифицированного подхода к работе с файловой системой
    - Сложности при рефакторинге и поддержке кода

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте жесткого кодирования</b></summary>

    Жесткое кодирование (hardcoding) - это практика разработки программного обеспечения, заключающаяся во встраивании данных непосредственно в исходный код программы.

    **Примеры потенциально жестко закодированных значений:**
    - Строки подключения к базам данных
    - Учетные данные и пароли
    - URL-адреса внешних сервисов и API
    - Пути к локальным или сетевым папкам
    - Идентификаторы объектов в системах
    - Адреса электронной почты
    - Константы бизнес-процессов
    - IP-адреса и номера портов
    - Тексты сообщений для пользователей
    - Параметры конфигурации робота

    **Рекомендации:**
    - Выносите все конфигурационные данные в ассеты PIX Master
    - Для безопасности используйте зашифрованные хранилища для чувствительных данных (Есть ассеты с зашифрованным типом)
    - Создавайте константы только для действительно неизменяемых значений
    - Используйте переменные окружения для зависимых от среды параметров

    **Преимущества отказа от жесткого кодирования:**
    - Гибкость: легко менять параметры без изменения и перекомпиляции кода
    - Безопасность: чувствительные данные не хранятся в исходном коде
    - Масштабируемость: одна и та же сборка может работать в разных средах с разными параметрами
    - Упрощение тестирования: можно легко переключаться между тестовыми и рабочими настройками
    - Улучшение поддержки: снижение риска появления "магических чисел" и значений, значение которых непонятно
    - Централизованное управление: все настройки собраны в одном месте

    **Последствия жесткого кодирования:**
    - Сложность внесения изменений: требуется изменение кода и перекомпиляция
    - Риски безопасности: учетные данные и пароли могут попасть в репозитории кода
    - Отсутствие гибкости: невозможно быстро реагировать на изменения в окружении
    - Сложность поддержки: требуется понимание контекста для каждого жестко закодированного значения
    - Проблемы с масштабированием: невозможно легко переносить решение в другие среды
    - Дублирование данных: одни и те же значения могут повторяться в разных частях кода

    **Рекомендуемые инструменты для PIX:**
    - Ассеты мастера для хранения конфигурационных данных
    - Защищенные ассеты для хранения чувствительных данных
    - Аргументы запуска робота для передачи динамических параметров

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте большого кода в активности 'Выполнить'</b></summary>

    Использование большого кода в данной активности приводит к усложнению отладки, т.к. нет возможности отладить код (нет точки остановки, не возможно просматривать контекст) внутри этой активности.

    Лучше разбить код на несколько активностей, или полностью отойти от нее.

    ![activity](/common/UseCSharp.png)

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте Boxing и Unboxing</b></summary>

    По сравнению с простыми операциями присваивания операции упаковки и распаковки являются весьма затратными процессами с точки зрения вычислений. При выполнении упаковки типа значения необходимо создать и разместить новый объект. Объем вычислений при выполнении операции распаковки, хотя и в меньшей степени, но тоже весьма значителен.

    [Источник (Microsoft)](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/types/boxing-and-unboxing#performance)

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте комментариев</b></summary>
    Комментарии не нужны, пишите самодокументируемый код.
    Если комментарии необходимы, стоит задуматься об чистоте кода<p>

    Исключения:
    - TODO
    - Поведения, противоречащее логике

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте флагов в аргументах</b></summary>
    Флаг указывает на то, что у метода есть несколько функций. Лучше всего, если у метода есть только одна функция (принцип SRP). Разделите метод на две части, если логический параметр добавляет к методу несколько функций.

    - упрощает поддержку
    - упрощает модульное тестирование

    Например вместо CreateFile → CreateFile, CreateTempFile

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте глубоких вложенний</b></summary>
    Добавить

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

</details>

<details>
    <summary><b>Избегайте отрицательных условий</b></summary>
    Добавить

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Избегайте громоздких if-ов</b></summary>
    Добавить

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Временные решения</b></summary>

    - Если скрипт часто вызывается, замените его на контейнер (пока не решится вопрос логами)

    **[⬆ К началу статьи](#в-этой-статье)**

</details>

## Рекомендации документации роботов // Не использовать: На удалении Будет переделана и вынесена во внутренний confluence

<details>
    <summary><b>Общие рекомендации по документированию</b></summary>

Документация является критически важной частью разработки роботов и должна фиксироваться отдельными коммитами с типом `docs`:

**Типы документации для роботов PIX RPA:**

1. **Внешняя документация** (отдельные файлы и руководства):
   - README.md с общим описанием робота, его назначением и требованиями
   - Руководство по установке и настройке робота
   - Спецификации API и интеграций
   - Инструкции по обработке ошибок и устранению неполадок
   - Документация по архитектуре и потоку работы

2. **Внутренняя документация** (комментарии в коде):
   - Описания назначения и логики работы сложных скриптов
   - Пояснения к неочевидным решениям или обходным путям
   - Документация по ограничениям и особенностям работы
   - Комментарии к публичным интерфейсам и контрактам между модулями

**Рекомендации по документированию роботов:**
- Создавайте документацию параллельно с разработкой, а не "после"
- Обновляйте документацию при изменении функциональности
- Используйте стандартные форматы (Markdown для текстовых документов)
- Включайте диаграммы и визуальные пояснения сложных процессов
- Добавляйте примеры типичных сценариев использования
- Документируйте не только успешные сценарии, но и обработку ошибок

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Структура документации проекта</b></summary>

Хорошо организованная документация должна иметь четкую структуру и охватывать все аспекты работы робота.

**Рекомендуемая структура документации:**

1. **README.md** - основной документ проекта:
   - Название и краткое описание робота
   - Решаемые бизнес-задачи
   - Технические требования и зависимости
   - Краткая инструкция по установке
   - Ссылки на детальную документацию
   - Контактная информация для поддержки

2. **Техническая документация**:
   - Архитектура и принципы работы
   - Диаграммы процессов и состояний
   - Описание модулей и их взаимодействия
   - Интеграции с внешними системами
   - Обработка ошибок и исключительных ситуаций

3. **Руководство по установке и настройке**:
   - Пошаговая инструкция по развертыванию
   - Настройка параметров и ассетов
   - Требования к окружению
   - Проверка работоспособности

4. **Руководство пользователя**:
   - Описание пользовательского интерфейса (если есть)
   - Типичные сценарии использования
   - Решение распространенных проблем
   - Часто задаваемые вопросы

5. **CHANGELOG.md**:
   - История изменений по версиям
   - Добавленная функциональность
   - Исправленные ошибки
   - Устаревшие или удаленные возможности

**Форматирование документации:**
- Используйте заголовки разных уровней для структурирования
- Добавляйте оглавление для объемных документов
- Выделяйте важную информацию (предупреждения, советы)
- Включайте скриншоты и изображения для наглядности
- Используйте списки и таблицы для структурирования информации

**[⬆ К началу статьи](#в-этой-статье)**

</details>

<details>
    <summary><b>Комментирование кода</b></summary>

Грамотное комментирование кода является ключевым аспектом документирования роботов PIX RPA.

**Общие принципы комментирования:**
- Комментарии должны объяснять "почему", а не "что" делает код
- Избегайте очевидных комментариев, описывающих и так понятные операции
- Фокусируйтесь на бизнес-логике и неочевидных технических решениях
- Обновляйте комментарии при изменении кода

**Рекомендуемые места для комментариев:**

1. **Заголовок скрипта/функции**:
   ```csharp
   // Функция для валидации входных данных транзакции
   // Проверяет обязательные поля и форматы данных
   // Возвращает: true если данные корректны, false если есть ошибки
   ```

2. **Сложные алгоритмы и бизнес-логика**:
   ```csharp
   // Алгоритм приоритизации задач:
   // 1. Сначала обрабатываем срочные задачи (priority=1)
   // 2. Затем задачи с датой выполнения сегодня
   // 3. Остальные задачи в порядке создания
   ```

3. **Неочевидные решения и обходные пути**:
   ```csharp
   // Используем Thread.Sleep(500) перед запросом к API из-за
   // ограничения на стороне сервера (не более 2 запросов в секунду)
   ```

4. **Известные ограничения**:
   ```csharp
   // ВНИМАНИЕ: Функция работает корректно только с файлами до 10MB
   // Для больших файлов используйте ChunkedFileProcessor
   ```

5. **TODO и планируемые изменения**:
   ```csharp
   // TODO: Заменить на асинхронную версию после обновления библиотеки
   ```

**Практики, которых следует избегать:**
- Комментарии, противоречащие коду
- Закомментированные блоки устаревшего кода (используйте систему контроля версий)
- Избыточное комментирование очевидных операций
- Комментарии без актуализации при изменении кода

**[⬆ К началу статьи](#в-этой-статье)**

</details>